<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Sunday, July 03 2019 .06-pre -->

<muclient>
<plugin
name="AARDWOLF_Affects_Window"
author="Khadaji, Elisius, Tinypotato"
id="353de94ba6c43260d839e256"
save_state="y"
language="Lua"
purpose="Affects Window"
date_written="2019-07-03 12:04:56"
requires="5.00"
version="1.0"
>

</plugin>

<!--  Timers  -->

<timers>
  <timer
      script="PlayAllMovieFrames"
      enabled="y"
      second="0.1"
      active_closed="y"
      >

  </timer>
</timers>


<!--  Aliases  -->

<aliases>
  <alias
      regexp="y"
      match="^affects window$"
      enabled="y"
      sequence="100"
      script="Toggle"
      >
  </alias>
    <alias
      regexp="y"
      match="^affects test$"
      enabled="y"
      sequence="100"
	  send_to="12"
      ><send></send>
  </alias>
  <alias
      regexp="y"
      match="^affects window debug$"
      enabled="y"
      sequence="100"
      script="ToggleDebug"
      >
  </alias>
  <alias
      regexp="y"
      match="^affects window gag prompt"
      enabled="y"
      sequence="100"
      script="TogglePromptGag"
      >
  </alias>
</aliases>

<!--  Triggers  -->

<triggers>
  <trigger
      enabled="y"
      match="^(?!You are hungry\.)(((You are )(no longer )?)|(Your ))(?<affect>full|hungry|thirst)( is quenched)?\.$"

      regexp="y"
      send_to="12"
      sequence="100"
      script="RemoveAffect"
      >
  </trigger>
  <trigger
      enabled="y"
      match="Your (magical )?(?<affect>charge) (dissipates|wears off)."
      regexp="y"
      send_to="12"
      sequence="100"
      script="RemoveAffect"
      >
  </trigger>
    <trigger
      enabled="y"
      match="^\{affon\}(?P<spell>\d+)\,(?P<duration>\d+)$"
      regexp="y"
      send_to="12"
      sequence="100"
      script="AddAffectTimed"
      >
  </trigger>
      <trigger
      enabled="y"
      match="^\{affoff\}(?P<affect>\d+)$"
      regexp="y"
      send_to="12"
      sequence="100"
      script="RemoveAffect"
      >
  </trigger>  
</triggers>

<!--  Script  -->

<script>
  <![CDATA[
	require "movewindow"
	require "mw"
	require "mw_theme_base"
	require "tprint"
	require "utility"

	-- Miniwindow State
	local winid = "win_"..GetPluginID()
	local version = "1.00"
	local hiddenWindow = winid.."text_background_offscreen"
	local bg_color = "#000000"
	local title_bg_color = "#303030"
	local border_color = "#303030"
	local title_color = "#FFFFFF" -- window title color
	local last_refresh = 1 -- last window refresh
	local pos_x = GetVariable("pos_x") or 100
	local pos_y = GetVariable("pos_y") or 100
	local font_size = 8
	local font_name = "Lucida Console"
	local window_visible = true -- always start out with visible window
	local title = "Affects Window"
	local win_height = tonumber(GetVariable("win_height")) or 400
	local win_width = tonumber(GetVariable("win_width")) or 440
	local grip_resize = 10 -- resize grip size
	local timer_color = Theme.BODY_TEXT
    -- the width and height of each image
    local image_size = GetVariable("image_size") or 32
    
    -- How tall each row of text is (for the timers)
    local text_height = 20
    -- The space between the icon and the text
    local text_margin_top = 2
	COOLDOWN_TEXT_COLOUR = ColourNameToRGB "yellow"
	tick_prefix = "This is a huge test:"
	current_time = ""

     -- When each spell will run out
    end_times = {}

	-- Global Vars
	infos = {}
	affects = {}
	warned_about_missing_files = false
	-- In game name to filename map

	affect_icons = {
	   ["58"] = "invis",
	   ["526"] = "elementalfocus",
	   ["71"] = "nayrus_love",
	   ["180"] = "nayrus_love",
	   ["6"] = "blind",
	   ["29"] = "curse",
	   ["74"] = "sleep",
	   ["53"] = "haste",
	   ["180"] = "haste",
	   ["237"] = "web",
	   ["hungry"] = "hungry",
	   ["thirsty"] = "thirsty"}

    -- We are using this as a set, these affects should be removed from the window
    -- and not draw a disabled state
    bad_affects = {
       ["6"] = "blind",
	   ["29"] = "curse",
	   ["237"] = "web",
	   ["74"] = "sleep"
    }

	path_prefix = "worlds\\plugins\\images\\affects\\"
    debug = GetVariable("debug") or false
    prompt_gag = GetVariable("prompt_gag") or false
    pulse_length = 1

	function NotifyNote(message)
	   ColourNote ("Green", "", message)
	end

	function ErrorNote(message)
	   ColourNote ("Red", "", message)
	end

	function DebugNote(message)
   if(debug) then
	   Note(message)
   end
	end

	function Toggle()
	   window_visible = not window_visible
   if not window_visible then -- remove window
	   WindowDelete(winid)
   else
	   window(true)
   end
	end

	function ToggleDebug()
	   debug = not debug
	   NotifyNote("Debug is now " .. tostring(debug))
	   SaveState()
	end

	function TogglePromptGag()
	   prompt_gag = not prompt_gag
	   stringified = not prompt_gag and "enabled" or "disabled"
	   NotifyNote("Prompts will now be " .. stringified)
	   SetupAffectTriggers()
	   SaveState()
	end
--------------------------------------------------------------------------------------------------------------------------------
-- UNDER CONSTRUCTION - THIS WILL BE USED TO TYPE SAFFECTS AND UPDATE THE TIMERS EVERY 120 SECONDS OR SO, TO KEEP THEM ON TIME
--------------------------------------------------------------------------------------------------------------------------------

	function AffectsListStart(name, line, wildcards)
	   DebugNote("got start of Affects")
	   EnableTrigger("aff_start_2", false)
	   flags = trigger_flag.Enabled + trigger_flag.RegularExpression
   if (prompt_gag) then
	   flags = flags + trigger_flag.OmitFromOutput
   end
	--  Spell   : Elemental ward (10:41)
	   AddTriggerEx("GRAB_SPELLS_TIME", "^Spell   : (.*?) (\\(\\d+:\\d+\\))$", "", flags, custom_colour.NoChange, 0, "", "AddAffectTimed", 0, 100)
	   print(wildcards[1])
	   print(wildcards[2])
	--  AddTriggerEx("GRAB_SPELLS_TIME", "^(.*?) +(?:modifies .*? -?\\d+ )?for (\\d+) pulses.*?$", "", flags, custom_colour.NoChange, 0, "", "AddAffectTimed", 0, 100)

	--  AddTriggerEx("GRAB_SPELLS_INDEFINITELY", "^(.*?) +(indefinitely).*$", "", flags, custom_colour.NoChange, 0, "", "AddAffect", 0, 100)
	   AddTriggerEx("AFF_END", "Spell   : Detect hidden (30:30)", "", flags + trigger_flag.OneShot, custom_colour.NoChange, 0, "", "AffectsListEnd", 0, 100)
	end -- AffectsListStart

	function AffectsListEnd(name, line, wildcards)
	   DebugNote("AffectsListEnd")
	   DeleteTrigger("GRAB_SPELLS_TIME")
	   DeleteTrigger("GRAB_SPELLS_INDEFINITELY")
	end -- AffectsListEnd


	-- --------------------------------------------------------------------
	-- AddAffect (name, line, wildcards)
	-- wildcards[1] must be in affect_icons table, otherwise prompt user for icons
	-- --------------------------------------------------------------------
	function AddAffectTimed(name, line, wildcards)
       -- DebugNote(wildcards[1])
       -- DebugNote(wildcards[2])
	   DebugNote("AddAffectTimed")
       if(wildcards[1] ~= nil and wildcards[2] ~= nil) then
           DebugNote("Spell: " .. wildcards[1])
           DebugNote("Duration: " .. wildcards[2])
           spell = wildcards[1]:lower()
           duration = tonumber(wildcards[2])
           local k, v = FindAffectInInfos(spell)
           spell = string.gsub(spell, " ", "_")
           if (k == -1 and duration > 0 and affect_icons[spell] ~= nil) then
               start_time = os.time() + duration
               DebugNote("Adding New Timed Affect")
               PlaceNewGIF(path_prefix .. affect_icons[spell], nil, start_time, true)
               hours, minutes, seconds = GetTimerTime(duration)
               DebugNote(string.format("%02d:%02d:%02d", hours, minutes, seconds))
               DebugNote("timer retval: " .. AddTimer(spell, hours, minutes, seconds, "", timer_flag.Enabled + timer_flag.OneShot, "RemoveAffectTimed"))
               DebugNote("timer: " .. GetTimer(spell))
               --tprint(infos)
               DebugNote(infos.x)
               --  local i, v = FindAffectInInfos(spell)
               --  tprint(FindAffectInInfos(spell)[1])
            elseif (duration > 0 and affect_icons[spell] ~= nil) then
              v.enabled = true
              v.start_time = os.time() + duration
	        end -- if
       end -- if
	end -- AddEffectTimed

	function GetTimerTime(pulses)
	   seconds = pulses * pulse_length
	   local hours = math.floor((seconds % 86400)/3600)
	   local minutes = math.floor((seconds % 3600)/60)
	   local seconds = math.floor(seconds % 60)
	   return hours, minutes, seconds
	end -- GetTimerTime

	-- --------------------------------------------------------------------
	-- AddAffect (name, line, wildcards)
	-- wildcards[1] must be in affect_icons table, otherwise prompt user for icons
	-- --------------------------------------------------------------------
	function AddAffect(name, line, wildcards)
	   DebugNote("AddAffect")
	   DebugNote(wildcards[1])
   if(wildcards[1] ~= nil) then
	   new_affect = wildcards[1]
   if (string.find(new_affect, "BODILYREQUIREMENTS")) then
   if (string.find(new_affect, "HUNGER THIRST")) then
	   DebugNote("BOTH")
	   AddAffect(name, line, {"hungry"})
	   AddAffect(Name, line, {"thirsty"})
   elseif (string.find(new_affect, "HUNGER")) then
	   DebugNote("HUNGER")
	   AddAffect(name, line, {"hungry"})
   elseif (string.find(new_affect, "THIRST")) then
	   DebugNote("Thirst")
	   AddAffect(name, line, {"thirsty"})
   end
    end

	   new_affect = FixWildcardsForHungerThirst(wildcards[1])
	   local k, v = FindAffectInInfos(new_affect)
	   DebugNote(new_affect)
   if(k == -1) then
   if(affect_icons[new_affect] ~= nil) then
	   PlaceNewGIF(path_prefix .. affect_icons[new_affect], true)
   end
    end -- if
	 end -- if
	  end -- AddEffect

	function FixWildcardsForHungerThirst(match)
   if (match == "HUNGER" or match == "full") then
       match = "hungry"
   elseif (match:lower() == "thirst") then
	   match = "thirsty"
   elseif (match:lower() == "broth") then
	   match = "both"
   end -- if
	   return match
	end

	-- --------------------------------------------------------------------
	-- RemoveAffectTimed (name, line, wildcards)
	-- wildcards[1] must be an active effect
	-- --------------------------------------------------------------------
	function RemoveAffectTimed(name, line, wildcards)
	   DebugNote("RemoveAffectTimed")
	   name = string.gsub(name, "_", " ")
	   DebugNote(name)


       if(name ~= nil) then
           local k, v = FindAffectInInfos(name)
	       DebugNote("k:" .. tostring(k))
           if (k >= 0) then
	         DebugNote("Seting affect to off " .. tostring(k))
             spell = wildcards[1]:lower()
             if(affect_icons[new_affect] ~= nil) then
               DebugNote("Showing disabled icon for "..spell)
	           --table.remove(infos, k)
             else
               DebugNote("Ignoring spell, no known icon "..spell)
             end

	    --     window(true) -- Redraw   (THIS WAS CAUSING FLICKERING)
           end -- if
	      end -- if
	end -- RemoveAffect

	-- --------------------------------------------------------------------
	-- RemoveAffect (name, line, wildcards)
	-- wildcards[1] must be an active effect
	-- --------------------------------------------------------------------
	function RemoveAffect(name, line, wildcards)
	   DebugNote(wildcards[1])
	   DebugNote("RemoveAffect")
   if(wildcards["affect"] ~= nil) then
	   affect = wildcards["affect"]
	   affect = FixWildcardsForHungerThirst(affect)
	   affect = affect:lower()
	   -- Handle broth
   if (affect == "both") then
	   DebugNote("Handling Broth")
	   wildcards["affect"] = "hunger"
	   RemoveAffect(name, line, wildcards)
       wildcards["affect"] = "thirsty"
	   RemoveAffect(name, line, wildcards)
   do return end
   end -- if
	   DebugNote(affect)
	   local k, v = FindAffectInInfos(affect)
	   DebugNote("k:" .. tostring(k))
   if (k >= 0) then
       if (bad_affects[wildcards[1]]) then
	     DebugNote("Removing bad affect " .. tostring(k))
	     table.remove(infos, k)
		 --tprint(infos)
		 v.enabled = false
		 -- Clear out the pixels of where the removed spell is going to be, and then draw it again using PlayMovieFrame (v)
		 WindowRectOp (winid, 2, movieInfo.x, movieInfo.y, movieInfo.x + image_size, movieInfo.y + image_size, ColourNameToRGB("bg_color"))
		 WindowRectOp (winid, 2, movieInfo.x, movieInfo.y + image_size + text_margin_top, movieInfo.x+image_size, movieInfo.y + image_size + text_margin_top + text_height, ColourNameToRGB("bg_color"))
		 PlayMovieFrame (v) -- this is added in place of window(true) to avoid the flickering (MAYBE MOVE BACK DOWN TO WINDOW(TRUE) SPOT)
       else
         DebugNote("Showing disabled icon for "..spell)
         v.enabled = false
	     affect = string.gsub(affect, " ", "_")
	     DebugNote(affect)
	     DebugNote(DeleteTimer(affect))
       end
	 --  window(true) -- Redraw (THIS WAS CAUSING FLICKERING)
   end
	end
	 end -- RemoveAffect

	function FindAffectInInfos(name)
   for k, v in pairs(infos) do
   if (affect_icons[name] ~= nil and string.match(v.filename, affect_icons[name]) ~= nil) then
		 return k, v
   end
	end
	 return -1, -1
	  end -- FindAffectInInfos

	function GetNumFrames(filename)
	   return GetNumFramesHelper(filename, 0)
	end -- GetNumFrames

	function GetNumFramesHelper(filename, i)
	   old_filename = filename
	   filename = string.format (filename, i + 1)
	   DebugNote("filename_numframehelp = " .. filename)
	   local f = io.open(filename, "r")
   if f ~= nil and i < 1000 then
	   io.close(f)
	   filename = old_filename
	   return GetNumFramesHelper(filename, i + 1)
   else
	   DebugNote("f no exists::i=" .. tostring(i))
	      return i
	   end
	end -- GetNumFrames

	-- --------------------------------------------------------------------
	-- PlayGif (info)
	--  info.filename (eg. "/frames/my_Gif_%03i.png" )
	--  info.frames   (eg. 10, if the Gif consists of 10 files)
	--  info.x   - X position on screen
	--  info.y   - Y position on screen

	--  Suggested conversion:
	--    ffmpeg -ss "00:30" -i INPUTFILE.mp4 -t 1     -r 10 -s 720x404 frames/my_Gif_%03i.png
	--                ^^^^          ^^^       ^^^^     ^^^^^    ^^^^^^^    ^^^^^^^^^^
	--           Start time      input file  how long   FPS       size      output files
	-- --------------------------------------------------------------------

	function PlayMovie (info)
	   movieInfo = info

   if not info then
	   return
   end -- if

	   assert (type (movieInfo) == "table",
	   "Argument to PlayMovie should be a table")

	   -- see if already in table
	   if infos [info.filename] then
	      --return
	   end -- if already there

	   local gotErrors = false

   -- load the disabled frame into memory
   if not WindowImageInfo(winid, movieInfo.disabled_filename, 2) then
       local result = WindowLoadImage(winid, movieInfo.disabled_filename, movieInfo.disabled_filename)
   end

	   -- load each movie frame into memory, if not already done
   for i = 1, movieInfo.frames do
   local filename = string.format (movieInfo.filename, i)
   if not WindowImageInfo(winid, filename, 2) then
       local result = WindowLoadImage(winid, filename, filename)

   if result ~= error_code.eOK then
	   ErrorNote ("Could not open move frame file:")
	   ErrorNote ("   -> " .. filename)
	   ErrorNote ("   Reason: " .. error_desc [result])
	   gotErrors = true
   end -- if
	end -- if
	 end -- for each frame


	   -- if couldn't do it, discard the movie info
   if gotErrors then
	   movieInfo = nil
   return
   end -- if

	   -- otherwise, start at frame 1
	   movieInfo.currentFrame = 1

	   -- put into table of infos
	   table.insert(infos, movieInfo)
	end -- PlayMovie

	-- --------------------------------------------------------------------
	-- PlayMovieFrame - show current frame, advance count
	-- --------------------------------------------------------------------
	function PlayMovieFrame (movieInfo)
       -- timing stuff
	   timeTaken = timeTaken or 0
	   frameCount = frameCount or 0

	   local startTime = utils.timer ()
	   local filename
       local errorCode
       
       local imageWidth = image_size
       local imageHeight = image_size

       -- Draw the correct frame number if the spell is enabled, otherwise draw the disabled image
       if (movieInfo.enabled) then
         filename = string.format (movieInfo.filename, movieInfo.currentFrame)
         errorCode = WindowDrawImage (winid, filename, movieInfo.x, movieInfo.y, movieInfo.x + imageWidth, movieInfo.y + imageHeight, miniwin.image_stretch)
       else
         filename = movieInfo.disabled_filename

         -- Because this is a partially transparent image, need to clear out any pixels before drawing
		 --TODO: ADD IF STATEMENT BELOW TO ONLY DO THIS WINDOWRECTOP IF ITS A BADEFFECT, OTHERWISE DON'T
         WindowRectOp (winid, 2, movieInfo.x, movieInfo.y, movieInfo.x + imageWidth, movieInfo.y + imageHeight, ColourNameToRGB("bg_color"))
		 if WindowInfo("hiddenWindow", 4) == nil then
			DebugNote("No hidden window, creating it now!")
			WindowCreate (hiddenWindow, 0, 0, 0, 0, 12, 3, ColourNameToRGB(bg_color))
		end

         -- Here we need to draw the image in a hidden window, resize that window, draw the image transparently, and later draw it stretched
		 image_down = filename
		 if WindowLoadImage (hiddenWindow, image_down, filename) == 0 then
			WindowResize (hiddenWindow, WindowImageInfo(hiddenWindow, image_down, 2), WindowImageInfo(hiddenWindow, image_down, 3), ColourNameToRGB(bg_color))
			WindowDrawImageAlpha (hiddenWindow, image_down, 0, 0, 0, 0, 0.3)
			WindowImageFromWindow(winid, image_down, hiddenWindow)
		 end
       -- if not string.match(image_down, "%w+_down.png") then 
			DebugNote(path_prefix)
         -- Now go ahead and draw the image (used to be alpha, and instead of stretch, 0.5)
         errorCode = WindowDrawImage (winid, image_down, movieInfo.x, movieInfo.y, movieInfo.x + imageWidth, movieInfo.y + imageHeight, miniwin.image_stretch)
		 WindowRectOp (winid, 2, movieInfo.x,  movieInfo.y + image_size + text_margin_top, movieInfo.x+image_size,  movieInfo.y + image_size + text_margin_top + text_height, ColourNameToRGB("bg_color"))
		 -- Now set the down_image to nothing, so it can draw the next one.
		 	image_down = 0
		--else
		--	errorCode = error_code.eOK
		--	WindowRectOp (winid, 2, movieInfo.x,  movieInfo.y + image_size + text_margin_top, movieInfo.x+image_size,  movieInfo.y + image_size + text_margin_top + text_height, ColourNameToRGB("bg_color"))
		--	DebugNote("THIS IS GOOD")
			
		--end
       end
       --long WindowDrawImage(BSTR WindowName, BSTR ImageId, long Left, long Top, long Right, long Bottom, short Mode, long SrcLeft, long SrcTop, long SrcRight, long SrcBottom);

	   	   	   -- Redraw icons
   if (#infos >= 1) then
	tmp_infos = infos
	infos = {}
	warned = false
for i, v in ipairs(tmp_infos) do
	x, y = FindNextPos(image_size)
	v.x = x
	v.y = y
if(not warned and (x > win_width or y > win_height)) then
	warned = true
	Note("Your Affects window is too small to show all the icons, make it bigger!")
end
	table.insert(infos, v)
 end
end

	   if errorCode ~= error_code.eOK then
	   ErrorNote ("Could not draw image: " .. filename)
	   end -- if
	   end_time = os.time()
	   current_time = start_time - end_time
	   CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")

       -- next frame
	   movieInfo.currentFrame = movieInfo.currentFrame + 1

       -- wrap
   if movieInfo.currentFrame > movieInfo.frames then
	   movieInfo.currentFrame = 1
   end -- if

       -- add up how long we took doing this
	   timeTaken = timeTaken + utils.timer () - startTime
       -- and how many times
	   frameCount = frameCount + 1
	end -- PlayMovieFrame
	   lastRefresh = 0
	function time_left()
	   duration = duration -
	   DebugNote(duration)
   if duration then
       return string.format("%2i", duration - os.time())
   else
       return "??"
   end
    end

	-- --------------------------------------------------------------------
	-- PlayAllMovieFrames - called by a timer every 1/10 second - calls
	--                      PlayMovieFrame for each movie in the table
	-- --------------------------------------------------------------------
	function PlayAllMovieFrames (timerName)
	   for i, j in ipairs(infos) do
           if (infos[i].enabled) then
               -- Only display the timer if the spell is enabled
               local spell_timer = infos[i].start_time - os.time() or 0

               if spell_timer >= 600 then
               timer_color = ColourNameToRGB("lime")
               elseif spell_timer <= 599 and spell_timer >= 120 then
               timer_color = ColourNameToRGB("yellow")
               elseif spell_timer <= 119 then
               timer_color = ColourNameToRGB("red")
               end
        --	    for k, v in pairs (infos) do
               WindowRectOp (winid, 2, infos[i].x, infos[i].y + image_size + text_margin_top, infos[i].x+image_size, infos[i].y + image_size + text_margin_top + text_height, ColourNameToRGB("bg_color"))
               
               -- [DONE]TODO: Center the text using WindowTextWidth to compute text width before hand 
			  timerWidth = WindowTextWidth(winid, "font", spell_timer)
			--  print(timerWidth)
               WindowText(winid, "font", spell_timer, infos[i].x + image_size/4, infos[i].y + image_size + text_margin_top, 0, 0, timer_color)
           end
       end

   for k, v in pairs (infos) do

       -- We need to redraw if any of the following are true:
       -- 1) v.lastDrawState == nil - the frame has never been drawn
       -- 2) v.enabled is true - the animation is showing, needs to be updated every frame
       -- 3) v.lastDrawState ~= v.enabled - we are switching from enabled to disabled
       if (v.lastDrawState == nil or v.enabled or v.lastDrawState ~= v.enabled) then
           PlayMovieFrame (v)
       end

       v.lastDrawState = v.enabled
   end

   end -- PlayAllMovieFrames

	function TableLength(T)
	   local count = 0
	   for _ in pairs(T) do count = count + 1 end
	   return count
	end

	-- 16x16 at top, 32x32 below
	-- Offsets due to window border
	x_off = 2
	y_off = 18
	gif_size = image_size
	-- --------------------------------------------------------------------
	-- PlaceNewGif (filename, frames)
	--  filename (eg. "bread" ), expected to be in worlds/plugins/images/frames/filename_%03i.png
	-- --------------------------------------------------------------------
	function PlaceNewGIF(filename, frames, start_time, enabled)
       local disabled_filename = filename.."_down.png"
       filename = filename.."_%03i.png"
	   DebugNote("PlaceNewGIF")
	   DebugNote("filename: " .. filename)
	   local rows = math.floor(win_height / gif_size)
	   local cols = math.floor(win_width / gif_size)
	   local frames = GetNumFrames(filename)
	   DebugNote("frames: " .. tostring(frames))
	   DebugNote("win_width " .. win_width)
	   DebugNote("win_height " .. win_height)
	   DebugNote("row " .. rows)
	   DebugNote("col " .. cols)
   if (frames ~= 0) then
	   num_gifs = #infos
	   movieInfo = info

	   -- Find position

	   x,y = FindNextPos(image_size)
	   PlayMovie {
	   filename = filename,
       disabled_filename = disabled_filename,
	   frames = frames,
	   x = x,
	   y = y,
       enabled = enabled,
       start_time = start_time}
   elseif(not warned_about_missing_files) then
	   warned_about_missing_files = true
	   ErrorNote ("Could not find any frames matching " .. filename)
   end
	end
--SHOULD THIS BE IMAGE_SIZE??
	function FindNextPos(size)
	   rows = math.floor(win_height / size)
	   cols = math.floor(win_width / size)
	   cur_col = math.floor((#infos) % cols)
	   cur_row = math.floor((#infos)/ cols) >= 0 and math.floor((#infos)/ cols) or 0
	   x = x_off + cur_col*size
	   y = y_off + cur_row*size + cur_row * (text_height + text_margin_top) 
	   --DebugNote("#infos " .. #infos)
	   --DebugNote("num_row " .. num_row)
	   --DebugNote("cur_row " .. cur_row)
	   --DebugNote("cur_row_test " .. cur_row_test)
	   --DebugNote("num_col " .. num_col)
	   --DebugNote("cur_col " .. cur_col)
	   --DebugNote("cols " .. cols)
	   --DebugNote("rows " .. rows)
	   return x, y
	end




	function window(redraw)
	   DebugNote("window(" .. tostring(redraw) .. ")")
	   if not window_visible then
	      return
	   end

   if redraw then
	   WindowDelete("winid")
	   WindowCreate(winid, pos_x, pos_y, win_width, win_height, 0, 0, ColourNameToRGB(bg_color))
	   WindowPosition(winid, pos_x, pos_y, 0, 2)
	   WindowSetZOrder(winid, 201)
	   WindowFont(winid, "f1", font_name, font_size, false, false, false, false)
	   WindowFont(winid, "b1", font_name, font_size, true, false, false, false)
	   WindowFont(winid, "s1", font_name, font_size - 1, false, false, false, false)
	   movewindow.install(winid, 6, 2, true, nil, {mouseup=MouseUp, mousedown=MouseDown, dragmove=LeftClickOnly, dragrelease=LeftClickOnly})
	   -- register with the z-order monitor
	   CallPlugin("462b665ecb569efbf261422f", "registerMiniwindow", winid)
	   movewindow.add_drag_handler (winid, 0, 0, 0, win_height)
	   WindowAddHotspot(winid, "resize", win_width - grip_resize, win_height - grip_resize, win_width, win_height, "MouseOver", "CancelMouseOver", "MouseDown", "", "MouseUp", "", 6, 0)
	   WindowDragHandler(winid, "resize", "ResizeMoveCallback", "ResizeReleaseCallback", 0)
   else
	   WindowResize(winid, win_width, win_height, ColourNameToRGB(bg_color))
	   WindowMoveHotspot(winid, "resize", win_width - grip_resize, win_height - grip_resize, win_width, win_height)
	  end
	   WindowShow(winid, true)
	   show_window()
	   end



	function show_window()
	   WindowRectOp(winid, 2, 2, 1, -2, -2, ColourNameToRGB(bg_color)) -- blank canvas
	   --WindowRectOp(winid, 2, 0, 0, 0, 22, ColourNameToRGB(title_bg_color)) -- title background
	   --WindowRectOp(winid, 1, 0, 0, 0, 0, ColourNameToRGB(border_color)) -- border
	   --Theme.Draw3DRect(winid, 0, 0, 0, 0, depressed) -- themed window

	   title = "Affects Window" -- default title

	   Theme.DrawTitleBar(winid, "f1", title, "center") -- them window title (has to be drawn before border) This is the title bar that says the leader name
	   Theme.DrawBorder(winid) -- theme window border
	   left, top = 7, 17 -- bar location
	   across = 0
	   rows = 0
	   Theme.AddResizeTag(winid, 2, nil, nil, "MouseDown", "ResizeMoveCallback", "ResizeReleaseCallback") -- resize grip
	   CallPlugin("abc1a0944ae4af7586ce88dc", "BufferedRepaint")
	end

	function ResizeMoveCallback()
	   --DebugNote("ResizeMoveCallback")
	   local x_offset, y_offset = start_x - WindowInfo(winid, 17), start_y - WindowInfo(winid, 18)
	   start_x, start_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
	   win_width = win_width - x_offset
	   win_height = win_height - y_offset
   if os.clock() - last_refresh >= .05 then
	   --DebugNote("redraw")
	   last_refresh = os.clock()
	   window(false)
   end
	end

	function ResizeReleaseCallback()
	   --DebugNote("ResizeReleaseCallback")
	   window(true)
	   SaveState()
	end

	function MouseDown(flags, id)
	   --DebugNote("MouseDown")
   if id == "resize" then
	   start_x, start_y = WindowInfo(winid, 17), WindowInfo(winid, 18)
   end
	end

	function MouseUp(flags, id, win)
	   --DebugNote("MouseUp")
	   if bit.band(flags, 0x20) ~= 0 then -- right click
	      right_click_menu()
	   end
	   pos_x, pos_y = WindowInfo(winid, 10), WindowInfo(winid, 11)
	   SaveState()
	end

	function right_click_menu()
	   local x, y = WindowInfo(winid, 14), WindowInfo(winid, 15)

	   local str = "!"

	   str = str.."Bring to Front"

	   str = str.."|-|Send to Back"
       
       str = str.."|-|Set images to small (32)"
       
       str = str.."|-|Set images to large (64)"

	   opt = WindowMenu(winid, x, y, str)

	   if opt == "" then
	      return
	   end

	   opt = tonumber(opt)

   if opt == 1 then -- Bring to Front
	   CallPlugin("462b665ecb569efbf261422f","boostMe", winid)
	   --  print("Bring to Front")
   elseif opt == 2 then -- Send to back
	   CallPlugin("462b665ecb569efbf261422f","dropMe", winid)
	   --  print("Sent to Back")
   elseif opt == 3 then -- Image size small
       image_size = 32
	   SetVariable("image_size", image_size)
   elseif opt == 4 then -- Image size large   
       image_size = 64
	   SetVariable("image_size", image_size)
   end
   SaveState()
	   window(true)
    end

	function CancelMouseOver(flags, id)
	   --DebugNote("CancelMouseOver")
	   -- nothing
	end

	function CancelMouseDown(flags, id)
	   --DebugNote("CancelMouseDown")
	   -- nothing
	end

	function SaveState()
	   SetVariable("pos_x", pos_x)
	   SetVariable("pos_y", pos_y)
	   SetVariable("win_width", win_width)
	   SetVariable("win_height", win_height)
	   SetVariable("debug", tostring(debug))
	   SetVariable("prompt_gag", tostring(prompt_gag))
	end
	function TogglePromptGag()
	   prompt_gag = not prompt_gag
	   stringified = not prompt_gag and "enabled" or "disabled"
	   NotifyNote("Prompts will now be " .. stringified)
	   SetupAffectTriggers()
	   SaveState()
	end

	function SetupAffectTriggers()
	   DebugNote("function SetupAffectTriggers()")
	   flags = trigger_flag.Enabled + trigger_flag.RegularExpression
	   if (prompt_gag) then
	      flags = flags + trigger_flag.OmitFromOutput
	   end
	   DebugNote(flags)
	   DebugNote(prompt_gag)
	   DebugNote(DeleteTrigger("aff_start_1"))
	   DebugNote(DeleteTrigger("aff_start_2"))
	 --  DebugNote(AddTriggerEx("aff_start_1", "^You are affected by the following:$", "", flags, custom_colour.NoChange, 0, "", "enable_aff_start_2", 0, 100))
	   DebugNote(AddTriggerEx("aff_start_1", "^You are affected by the following:$", "", flags - trigger_flag.Enabled, custom_colour.NoChange, 0, "", "enable_aff_start_2", 0, 100))
	   DebugNote("Setup")
	   DebugNote(AddTriggerEx("aff_start_2", "$Spell   : Detect hidden \\(\\d+:\\d+\\)", "", flags - trigger_flag.Enabled, custom_colour.NoChange, 0, "", "AffectsListStart", 0, 100))
	end

		function enable_aff_start_2()
	   DebugNote(EnableTrigger("aff_start_2", true))
	end

	function loaded()
		util.print("@W--------------------------------------------------------------------------------")
		util.print("@WPlugin Name  : @RG@Yr@Ga@Cp@Bh@Mi@mc@Ra@Yl @x238Affects Window")
		util.print("@WAuthor       : @x238Khadaji, TinyPotato")
		util.print("@WVersion      : @G" .. version)
		util.print("@W--------------------------------------------------------------------------------")
		end

	function OnPluginInstall()
	   debug = false
	   WindowFont(winid, "font", font_name, font_size, false, false, false, false, 0)
	   SetupAffectTriggers()
	   window(true)
	   
	   DoAfterSpecial(.2, "loaded()", 12)
	end

	function OnPluginEnable()
	   window(true)
	end

	function OnPluginDisable()
	   WindowDelete(winid)
	end

	function OnPluginClose()
	   WindowDelete(winid)
	end

	function OnPluginConnect()
	   DebugNote("OnPluginConnect")
	   SetupAffectTriggers()
	end

	function OnPluginSaveState()
	   SaveState()
	end

	function OnPluginWorldSave()
	   SaveState()
	end

	function OnPluginDisable()
	   SaveState()
	end

	function OnPluginDisconnect()
	   SaveState()
	end

------------------------------------------------TO DO --------------------------------------------------------
--[[***[HIGH PRIORITY]***
on login, reconnect, etc, type aflags to check for perm sanc and other effects
check saf sanc and aflags? ^^


If sanctuary is ON via some methods, and you wear the sanc aura, leave the timer and when it falls if the aura is on
change timer to PERMA


Aardwolf Aura of Sanctuary stops floating around you.
Aardwolf Aura of Sanctuary begins floating around you.

-- [DONE] MAKE NUMBERS SHOW GREEN WHEN OVER 10 MINUTES, YELLOW WHEN UNDER 10, RED WHEN UNDER 5 BLACK WHEN OFF?
add grey icons of all icons
add PERMA or infinity timer
add right click system to set priorities
add protection good icon
add protection evil icon
add sanc aura wear/remove
add haste boots wear/remove
handle wraith form

--check EQ on login/reconnect, etc. add string for wear/remove sanc aura/boots of speed, etc

--when logging on use priority system to load grey images of all priorities
-- FIX DRAWING OF TIMERS WHEN VERTICAL DRAWING
-- ADD AN ACTUAL FUCKTON MORE AFFECT_ICONS AND ASSIGN TO SPELL NUMBERS                                    ]]--
	----------------------------------------------------------------------------------------------------------
	----------------------------------------------------------------------------------------------------------

	-- For saving state when reloading w/ bast's plugins plugin
	function OnPluginListChanged()
	   SaveState()
	end

	window(true)
    ]]>
</script>

</muclient>